# 2.3 创建PHP变量 

我们已经知道php变量在内核中其实是通过zval结构来实现的，也初步了解如何设置一个zval结构的类型和值。
这一节我们将在前两节的基础上，彻底掌握对zval结构的操控，其间将引入很多超棒的新宏。

在code的时候，很希望在内核中创建的zval可以让用户在PHP语言里以变量的形式使用，为了实现这个功能，
我们首先要创建一个zval。最容易想到的办法便是创建一个zval指针，
然后申请一块内存并让指针指向它。如果你脑海里浮现出了malloc(sizeof(zval))的影子，
那么请你立即刹车，不要用malloc来做这件事情，内核给我们提供了相应的宏来处理这件事，
理由和以前一样：为了代码漂亮并保持版本升级时的兼容性。
这个宏的是：zvals are always pre-allcocated or allocated in stack(nomore MAKE_STD_ZVAL and ALLOC_ZVAL)，
直觉告诉我这个改变跟再也看不到"_PP"的宏有千丝万缕的关系．


申请完空间后(其实从代码上来看什么也没做-,-)，我们便可以给这个zval赋值了。基于已经介绍的宏，
也许我们需要Z_TYPE_P(p) = IS_NULL来设置其是null类型，并用Z_SOMEVAL形式的宏来为它赋值，
但是现在你有了更好更短的选择！

内核中提供一些宏来简化我们的操作，可以只用一步便设置好zval的类型和值。
<table>
			<tr>
				<td>新宏</td>
				<td>其它宏的实现方法</td>
			</tr>
			<tr>
				<td>ZVAL_NULL(pvz); **(注意这个Z和VAL之间没有下划线！)**</td>
				<td>Z_TYPE_INFO_P(pzv) = IS_NULL;**(IS_NULL型不用赋值，因为这个类型只有一个值就是null，^_^)**</td>
			</tr>
			<tr>
				<td>ZVAL_BOOL(pzv, b); **(将pzv所指的zval类型设为IS_TRUE或者IS_FLASE, _IS_BOOL是一个假类型＋＿＋)**</td>
				<td>Z_TYPE_INFO_P(pzv) = (b) ? IS_TRUE : IS_FALSE;**(_IS_BOOL型不用赋值，也是靠类型)**</td>
			</tr>
			<tr>
				<td>ZVAL_TRUE(pzv); **(将pzv所指的zval类型设置为IS_TRUE)**</td>
				<td>Z_TYPE_INFO_P(pzv) = IS_TRUE;</td>
			</tr>
			<tr>
				<td>ZVAL_FALSE(pzv); **(将pzv所指的zval类型设置为IS_FALSE)**</td>
				<td>Z_TYPE_INFO_P(pzv) = IS_FALSE;</td>
			</tr>
			<tr>
				<td>ZVAL_LONG(pzv, l);  **(将pzv所指的zval设置为IS_LONG类型，值是l)**</td>
				<td>Z_TYPE_INFO_P(pzv) = IS_LONG;<br />Z_LVAL_P(pzv) = l;</td>
			</tr>
			<tr>
				<td>ZVAL_DOUBLE(pzv, d); **(将pzv所指的zval设置为IS_DOUBLE类型，值是d)**</td>
				<td>Z_TYPE_INFO_P(pzv) = IS_DOUBLE;<br />Z_DVAL_P(pzv) = d;</td>
			</tr>
			<tr>
				<td>ZVAL_STR(pzv, str);</td>
				<td>Z_STR_P(pzv) = str;<br />Z_TYPE_INFO_P(z) = ZSTR_IS_INTERNED(s) ? IS_INTERNED_STRING_EX : IS_STRING_EX;</td>
			</tr>
			
			<tr>
				<td>ZVAL_RES(pzv, res);</td>
				<td>Z_TYPE_INFO_P(pzv) = IS_RESOURCE_EX;<br />Z_RES_P(pzv) = res;</td>
			</tr>			
		</table>


### ZVAL_STR



### ZVAL_RES约等于ZVAL_LONG



## links
   * [目录](<preface.md>)
   * 2.2 [变量的值](<2.2.md>)
   * 2.4 [变量的存储方式](<2.4.md>)

