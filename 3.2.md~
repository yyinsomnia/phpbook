# 3.2 引用计数 

对于PHP这种需要同时处理多个请求的程序来说，申请和释放内存的时候应该慎之又慎，一不小心便会酿成大错（更多对于扩展,内核开发而言，应用级别其实用起来还满宽心的－，－）。另一方面，除了要安全的申请和释放内存外，还应该做到内存的最小化使用，因为它可能要处理每秒钟数以千计的请求，为了提高系统整体的性能，每一次操作都应该只使用最少的内存，对于不必要的相同数据的复制则应该能免则免。我们来看下面这段PHP代码：
````php
<?php
$a = 'Hello World';
$b = $a;
unset($a);		
		
````
第一条语句执行后，PHP创建了$a这个变量，并为它申请了12B的内存来存放"hello world"这个字符串（最后加个NULL字符，你懂的）。紧接着把$a赋给了$b，并释放掉$a;
对于PHP来说，如果每一次变量赋值都执行一次内存复制的话，那需要额外申请12B的内存来存放这个重复的数据,当然为了复制内存，还需要cpu执行某些计算，这当然会加重cpu的负载。当第三句执行后，$a被释放了，我们刚才的设想突然变的这么滑稽，这次赋值显得好多余哦。如果早就知道$a不用了，那我们直接让$b用$a的内存不就行了，还赋值干嘛？如果你觉得12B没什么，那设想下如果$a是个10M的文件内容，或者20M，是不是我们的计算机资源消耗的有点冤枉呢？
别担心，PHP很聪明！
前面章节说过，PHP变量的名称和值在内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？
````c
	zend_string *a, *b;
	a = zend_string_init("a", sizeof("a") - 1, 0);
	b = zend_string_init("b", sizeof("b") - 1, 0);
	zval *helloval;
	ZVAL_STRING(helloval, "Hello World＂);
	zend_hash_add(&EG(symbol_table), a, helloval);
	zend_hash_add(&EG(symbol_table), b, helloval);
	//通过这个例子我们看出了，我们可以把$a和$b都指向helloval~!	
		
````
现在我们检查$a和$b两个变量，他们的值指向了"hello world"这个字符串在内存中的位置。但是在第三行：unset($a);这条语句释放了$a。在这种情况下，unset函数并不知道$a的值同时被$b用着，所以如果它直接释放内存，则会导致$b的值也被清空了，从而导致逻辑错误，甚至可能会导致系统崩溃。
呵呵，其实你心里明白，PHP不会让上述问题发生的！以上的例子笔者仅仅是把php5的写法对照翻译到了php7．在全新一代的php中(＾＿＾)，由zval引起了翻天覆地的变化．
实际使用中的ZVAL结构分为了两类:暂且我们给他们命名为ZVAL NON REFCOUNED 和　ZVAL REFCOUNED








图(待上)
可以看出新的优化具有针对性，标量类型不再走引用计数那一套，自然也没有了写时复制的机制．笔者现在只能揣测应该是对于这些简单类型的值，增加了引用计数的机制反而得不偿失吧．
而我们回过头再看看web开发中最常用的字符处理．zend_string


回顾一下zval的三个成员value、u1、u2，type在u1中，那ref相关的信息在哪儿呢？还是要根据上图区别分析．
以上描述转为内核中的代码大体如下：
````c
	zval helloval;
	ZVAL_STRING(helloval, "Hello World");
	zend_hash_add(&EG(symbol_table), zend_string_init("a", sizeof("a") - 1, 0), &helloval);
	Z_ADDREF(helloval); //这句很特殊，我们显式的增加了helloval结构体的refcount，注意标量类型是不会有效果的
	zend_hash_add(&EG(symbol_table), zend_string_init("b", sizeof("b") - 1, 0), &helloval);	
		
````
这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！
### 写时复制机制
引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？
````c
	$a = 1;
	$b = $a;
	$b += 5;
    	
````
其实以上代码的是不涉及到引用计数的，也就不存在写时复制，标量类型的值都直接进行值拷贝．
再来一段代码：
````php
	$a = 'simida';
	$b = $a;
	$b .= ' oba';
    	
````
从代码逻辑来看，我们希望语句执行后$a仍然是'simida'，而$b则需要变成'simida oba'。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。

等等，这段话看起来是如此的顺畅是因为笔者犯懒直接把之前的php5的这段话挪用的这里，但我们再回顾一下zval:
````c
typedef struct _zval_struct     zval;

struct _zval_struct {
	zend_value        value;			/* value */
	union {
		struct {
			ZEND_ENDIAN_LOHI_4(
				zend_uchar    type,			/* active type */
				zend_uchar    type_flags,
				zend_uchar    const_flags,
				zend_uchar    reserved)	    /* call info for EX(This) */
		} v;
		uint32_t type_info;
	} u1;
	union {
		uint32_t     var_flags;
		uint32_t     next;                 /* hash collision chain */
		uint32_t     cache_slot;           /* literal cache slot */
		uint32_t     lineno;               /* line number (for ast nodes) */
		uint32_t     num_args;             /* arguments number for EX(This) */
		uint32_t     fe_pos;               /* foreach position */
		uint32_t     fe_iter_idx;          /* foreach iterator index */
	} u2;
};

````

发现问题了没有？zval里面是没有refcount的！那refcount在哪儿呢?对于string而言:

````c
struct _zend_string {
	zend_refcounted   gc;
	zend_ulong        h;                /* hash value */
	size_t            len;
	char              val[1];
};

````
所以$b = $a;时$a和$b各自拥有独立的zval，但是共同享用一个zend_string(zval.value指向同一个zend_string)，refcount则记录于zend_string中．


现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。

### Change on Write
如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？
<pre>
	$a = 1;
	$b = &$a;
	$b += 5;    	
    	</pre>
作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！
但是内核是怎么知道这一切的呢？zval里面是没有相关的属性的，php7中新增了一个zend_reference来解决这个问题．
````c
struct _zend_reference {
	zend_refcounted   gc;
	zval              val;
};
````
我们看到了熟悉的zend_refcounted   gc;在zend_string的结构体中也看到过
````c
struct _zend_refcounted {
	uint32_t         refcount;			/* reference counter 32-bit */
	union {
		struct {
			ZEND_ENDIAN_LOHI_3(
				zend_uchar    type,
				zend_uchar    flags,    /* used for strings & objects */
				uint16_t      gc_info)  /* keeps GC root number (or 0) and color */
		} v;
		uint32_t type_info;
	} u;
};
````
这里先看一个例子，入门这种事情通过例子来最能偷懒了－，－
````php
$a = [];  // $a                                     -> zend_array_1(refcount=1, value=[])
$b =& $a; // $a, $b -> zend_reference_1(refcount=2) -> zend_array_1(refcount=1, value=[])

$b[] = 1; // $a, $b -> zend_reference_1(refcount=2) -> zend_array_1(refcount=1, value=[1])

````
可以看出来zval中的zend_value        value;本来是指向zend_array的，通过&的使用，2个变量都指向了同一个zend_reference，然后再通过zend_reference的val(zval而不是zval *)的zend_array指到了这个hashtable．在这个过程中可以体会到新的zval(相对ZE2)概念上更像一个wrapper，当然在简单类型上就不是这样了．
````php
$a = 1;    // $a                                      . zval_1(value=1)
$b = $a;   // $b                                      . zval_2(value=1)
$c = & $a; // $a, $c -> zend_reference_1(refcount=2)  . zval_3(value=1)　这里不是zval_1哟
````

让我们来看一个综合起来的例子:
````php
$a = [];   // $a                                      ->zend_array_1(refcount=1, value=[])
$b = $a;   // $a, $b                                  ->zend_array_1(refcount=2, value=[])
$c = $b;   // $a, $b, $c                              ->zend_array_1(refcount=3, value=[])

$d = &$c;  // $a, $b                                  ->zend_array_1(refcount=3, value=[])
           // $c, $d  ->zend_reference_1(refcount=2)  ->zend_array_1(refcount=3, value=[])
           // 注意这里的4个变量都共享一个zend_array
           // zend_reference_1的refcount=2因为有2个变量指向它，　zend_array_1的refcount=3是1个zend_reference_1和2个变量指向它.

$d[] = 1;　 // $a, $b                                  ->zend_array_1(refcount=2, value=[])
           // $c, $d ->zend_referentce_1(refcount=2)  ->zend_array_2(refcount=1, value=[1])
           // 这个时候才复制zend_array



`````
### 引用计数的前世今生
php5的机制此处不再详细描述，有兴趣的读者可以参看本书的php5版本，看完之后可以体会一下下面这段代码在php5,php7两个版本下的表现:
````php
$array = range(0, 100000);
$ref = &$array;
var_dump($count($array));

````

参考来源
http://walu.cc/phpbook/index.md
http://nikic.github.io/

## links
   * 3.1 [内存管理](<3.1.md>)
   * 3.3 [3.3 第三章总结](<3.3.md>)

