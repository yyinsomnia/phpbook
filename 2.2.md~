# 2.2 变量的值 

PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头，并且P结尾和PP结尾的同上一节中的宏一样，
分别代表这参数是指针还是指针的指针。

此外，为了进一步方便我们的工作，内核中针对具体的数据类型分别定义了相应的宏。
如针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P)等。
(笔者再找寻以下宏的过程中崩溃了┭┮﹏┭┮ Z_BVAL、Z_BVAL_P，那在７里面怎么拿到呢？难道要用Z_TYPE_P(zval_p) == IS_TRUE) 来替代吗)
我们通过下面这个例子来应用一下这几个宏:

````c
void display_value(zval zv,zval *zv_p)
{
	if( Z_TYPE(zv) == IS_NULL )
	{
		php_printf("类型是 IS_NULL!\n");
	}
	
	if( Z_TYPE_P(zv_p) == IS_LONG )
	{
		php_printf("类型是 IS_LONG，值是：%ld" , Z_LVAL_P(zv_p));
	}
	
}	
		
````

string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度，
所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P与Z_STRLEN、Z_STRLEN_P。
前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。

````c
void display_string(zval *zstr)
{
    if (Z_TYPE_P(zstr) != IS_STRING) {
        php_printf("这个变量不是字符串!\n");
        return;
    }
    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));
    //这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。
}		
		
````

Array型变量的值其实是存储在C语言实现的HashTable中的，
我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P）这三个宏来访问数组的值。
如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏

````c
#define HASH_OF(p) (Z_TYPE_P(p)==IS_ARRAY ? Z_ARRVAL_P(p) : ((Z_TYPE_P(p)==IS_OBJECT ? Z_OBJ_HT_P(p)->get_properties((p)) : NULL)))
````

可以获取数组或对象的值

对象是一个复杂的结构体（zend_object结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。
内核中定义了以下组合宏让我们方便的操作对象：
Z_OBJ_HANDLE：返回handle标识符，
Z_OBJ_HT：handle表，
Z_OBJCE：类定义，
Z_OBJPROP：HashTable的属性，
Z_OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。
现在不用担心这些宏对象的意思，后续有专门的章节介绍object。

资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。有关资源的内容我们将在第9章展开叙述。

有关值操作的宏都定义在./Zend/zend_tyeps.h文件里：
````c
//操作整数的
#define Z_LVAL(zval)			(zval).value.lval
#define Z_LVAL_P(zval_p)		Z_LVAL(*(zval_p))

//操作IS_BOOL布尔型的


//操作浮点数的
#define Z_DVAL(zval)			(zval).value.dval
#define Z_DVAL_P(zval_p)		Z_DVAL(*(zval_p))


//操作字符串的值和长度的

/** ./Zend/zend_string.h begin */
#define ZSTR_VAL(zstr)  (zstr)->val
#define ZSTR_LEN(zstr)  (zstr)->len
#define ZSTR_H(zstr)    (zstr)->h
#define ZSTR_HASH(zstr) zend_string_hash_val(zstr)
/** ./Zend/zend_string.h end */


#define Z_STR(zval)			(zval).value.str
#define Z_STR_P(zval_p)			Z_STR(*(zval_p))

#define Z_STRVAL(zval)			ZSTR_VAL(Z_STR(zval))
#define Z_STRVAL_P(zval_p)		Z_STRVAL(*(zval_p))

#define Z_STRLEN(zval)			ZSTR_LEN(Z_STR(zval))
#define Z_STRLEN_P(zval_p)		Z_STRLEN(*(zval_p))

#define Z_STRHASH(zval)			ZSTR_HASH(Z_STR(zval))
#define Z_STRHASH_P(zval_p)		Z_STRHASH(*(zval_p))


//操作数组的
#define Z_ARR(zval)			(zval).value.arr
#define Z_ARR_P(zval_p)			Z_ARR(*(zval_p))

#define Z_ARRVAL(zval)			Z_ARR(zval)
#define Z_ARRVAL_P(zval_p)		Z_ARRVAL(*(zval_p))


//操作对象的
#define Z_OBJ(zval)			(zval).value.obj
#define Z_OBJ_P(zval_p)			Z_OBJ(*(zval_p))

#define Z_OBJ_HT(zval)			Z_OBJ(zval)->handlers
#define Z_OBJ_HT_P(zval_p)		Z_OBJ_HT(*(zval_p))

#define Z_OBJ_HANDLER(zval, hf)		Z_OBJ_HT((zval))->hf
#define Z_OBJ_HANDLER_P(zv_p, hf)	Z_OBJ_HANDLER(*(zv_p), hf)

#define Z_OBJ_HANDLE(zval)          	(Z_OBJ((zval)))->handle
#define Z_OBJ_HANDLE_P(zval_p)      	Z_OBJ_HANDLE(*(zval_p))

#define Z_OBJCE(zval)			(Z_OBJ(zval)->ce)
#define Z_OBJCE_P(zval_p)		Z_OBJCE(*(zval_p))

#define Z_OBJPROP(zval)			Z_OBJ_HT((zval))->get_properties(&(zval))
#define Z_OBJPROP_P(zval_p)		Z_OBJPROP(*(zval_p))

#define Z_OBJDEBUG(zval,tmp)		(Z_OBJ_HANDLER((zval),get_debug_info)?Z_OBJ_HANDLER((zval),get_debug_info)(&(zval),&tmp):(tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL))
#define Z_OBJDEBUG_P(zval_p,tmp)	Z_OBJDEBUG(*(zval_p), tmp)


//操作资源的
#define Z_RES(zval)			(zval).value.res
#define Z_RES_P(zval_p)			Z_RES(*zval_p)

#define Z_RES_HANDLE(zval)		Z_RES(zval)->handle
#define Z_RES_HANDLE_P(zval_p)		Z_RES_HANDLE(*zval_p)

#define Z_RES_TYPE(zval)		Z_RES(zval)->type
#define Z_RES_TYPE_P(zval_p)		Z_RES_TYPE(*zval_p)

#define Z_RES_VAL(zval)			Z_RES(zval)->ptr
#define Z_RES_VAL_P(zval_p)		Z_RES_VAL(*zval_p)

#define Z_REF(zval)			(zval).value.ref
#define Z_REF_P(zval_p)			Z_REF(*(zval_p))

#define Z_REFVAL(zval)			&Z_REF(zval)->val
#define Z_REFVAL_P(zval_p)		Z_REFVAL(*(zval_p))
		
````

## links
   * [目录](<preface.md>)
   * 2.1 [变量的类型](<2.1.md>)
   * 2.3 [创建PHP变量](<2.3.md>)

