# 2.5 变量的检索 

用户在PHP语言里定义的变量，我们能否在内核中获取到呢？
答案当然是肯定的，下面我们就看如何通过zend_hash_find()函数来找到当前某个作用域下用户已经定义好的变量。
zend_hash_find()函数是内核提供的操作HashTable的API之一，如果你没有接触过，可以先记住怎么使用就可以了。

````c
{
    zval *var_val;
    zend_string *var_name = zend_string_init("foo", sizeof("foo") - 1, 0);
    if (zend_hash_find(&EG(symbol_table),var_name) == SUCCESS)
    {
        php_printf("成功发现$foo!");
    }
    else
    {
        php_printf("全局下无法发现$foo.");
    }
}		
		
````

首先我们定义了一个指向指针的指针，然后通过zend_hash_find去EG(symbol_table)全局域下寻找名称为foo($foo)的变量，
如果成功找到，此函数将返回SUCCESS。看完代码，你肯定有很多疑问。



该回答的问题确实很多，不要过于担心，让我们带着这些问题继续往下走。

首先要说明的是，内核定义HashTable这个结构，并不是单单用来储存PHP语言里的变量的，
其它很多地方都在应用HashTable**(这就是个神器)**。
一个HashTable有很多元素，在内核里叫做bucket。然而每个bucket的大小是固定的，
跟之前php5中不同的，php7的HashTable中的所有bucket是连续分布的（所有bucket一次分配好），
每个bucket中存的并不是一个指向zval的指针而是zval本身．

如果zend_hash_find()函数找到了我们需要的数据，它将返回SUCCESS常量，
并把它的地址赋给我们在调用zend_hash_find()函数传递的fooval参数，
也就是说此时fooval就指向了我们要找的数据。如果没有找到，那它不会对我们fooval参数做任何修改，并返回FAILURE常量。  

就去符号表里找变量而言，SUCCESS和FAILURE仅代表这个变量是否存在而已。


## links
   * [目录](<preface.md>)
   * 2.4 [变量的存储方式](<2.4.md>)
   * 2.6 [类型转换](<2.6.md>)

